====================================
NSObjectクラスとランタイムシステム
====================================

NSObjectは、「isa」というClass型のインスタンス変数を持っており、すべてのインスタンスオブジェクトは、このisaによって自分が属しているクラスオブジェクトを参照しています。

NSObjectクラス
==================

クラスとインスタンスに関係するメソッド
---------------------------------------

- \- (Class) class

	レシーバの属するクラスのクラスオブジェクトを返します。

- \+ (Class) class

	クラスオブジェクトを返します、
	クラスメソッドを呼び出す場合には、クラス名をメッセージのレシーバとして用いますが、クラスオブジェクトを他のメッセージの引数としたり、変数に代入する場合などは、このクラスメソッドを使ってクラスオブジェクトを得る必要があります。

- \- (id) self

	レシーバ自体を返します。何の動作もしないメソッドとして役立つことがあります。

- \- (BOOL) isMemberObClass: (Class) aClass

	レシーバが引数のクラスのインスタンスかどうかを調べます。

- \- (BOOL) isKindOfClass: (Class) aClass

	レシーバが、引数のクラスのインスタンスか、あるいはそのクラスのサブクラスのインスタンスかどうかを調べます。
	このメソッドがisMemberObClass:と異なるのは、引数のクラスだけでなく、そのサブクラスのインスタンスである場合にもYESを返すという点です。

- \+ (BOOL) isSubclassOfClass: (Class) aClass

	レシーバが引数のクラスのサブクラスか、そのクラス自体である場合にYESを返します。

- \- (Class) superclass

	レシーバの属するクラスのスーパクラスのクラスオブジェクトを返します。

- \+ (Class) superclass

	レシーバのスーパークラスのクラスオブジェクトを返します。


インスタンスの生成と解放に関するメソッド
-----------------------------------------

- \+ (id) alloc

	レシーバとして指定されたクラスのインスタンスを生成します。生成されたインスタンスの初期化を完全に行うために、常に「init」あるいは「init...」で始まるメソッド、すなわちイニシャライザと組み合わせて用いる必要があります。

- \- (void) dealloc

	インスタンスを解放します。このメソッドはreleaseの結果として呼び出されます。
	サブクラスでdeallocを上書きする場合を除き、プログラムから直接呼び出してはいけません。

- \- (oneway void) release

	レシーバのリファレンスカウンタを１つ減らします。リファレンスカウンタが0になると、deallocメソッドをが呼び出され、レシーバが解放されます。

- \- (id) retain

	レシーバのリファレンスカウントを値として返します。

- \- (id) autorelease

	レシーバを現在有効な自動解放プールに追加し、レシーバ自体を返します。

- \- (NSUInteger) retainCount

	レシーバのリファレンスカウンタを値として返します。NSUIntegerは符号なし整数で、このメソッドはデバッグ用です。

- \- (void) finalize

	ガーベジコレクタがレシーバを解放する直前に実行します。

.. Note::

	上記の「dealloc」から「retainCount」までは手動がカウンタ管理方式でメモリ管理を行う場合に有効で、ARCでは利用できません。finalizeはガーベジコレクションを用いる際に有効です。


初期化に関するメソッド
------------------------

- \- (id) init

	「alloc」で生成されたインスタンスを初期化します。サブクラスでは「init」を上書きするか、または新たなイニシャライザを「init...」という名前で定義して初期化を行います。

+ \- (void) initialize

	クラスの初期化、つまり、クラス内で共通に使われる変数の初期設定等を行うのに利用します。このメソッドは、そのクラスに対して送られる初めてのメッセージに先立って自動的に実行されます。

+ \- (id) new

	一般には「alloc」と「init」の呼び出しを組み合わせたものです。「new」メソッドで返されるインスタンスのオーナーは、呼び出し側のオブジェクトになります。ただし、「alloc」と「init」の組み合わせとして「new」を改めて定義するメリットはほとんどありません。
	クラスによっては、「alloc」でその都度新しいインスタンスを生成するのではなく、あらかじめ生成したインスタンスをプールしておいて後から渡すようにしたり、同じ値を持つインスタンスを共有したりする仕組みを組込みたいことがあります。
	このような場合は、「new」メソッド、あるいは「new...」で始まるメソッドを用いることができます。


オブジェクトの比較に関するメソッド
---------------------------------------

- \- (BOOL) isEqual: (id) anObject

	レシーバと引数anObjectが等しいと判断される場合にYESを返します。

- \- (NSUInteger) hash

	オブジェクトをコレクションに格納するとき等、システムで内部的に利用されるハッシュ値を返します。

オブジェクトの内容を記述するメソッド
---------------------------------------

- \+ (NSString*) description

	レシーバのクラスの内容を表すNSStringの文字列を返します。通常はクラス名が返されます。

- \- (NSString*) description

	レシーバのインスタンスオブジェクトの内容を表すNSStringの文字列を返します。通常はクラスメイトid値を表示しますが、サブクラスによって独自の定義をすることもあります。
	例えば、NSStringのインスタンスは値として「self」を返します。また、NSArrayのインスタンスは、配列内の要素に対して「description」を定義した結果の文字列をカンマで区切って（）内に列挙した文字列を返します。


メッセージ送信
========================

メッセージを送信するメソッド
----------------------------

- \- (id) performSelector: (SEL) aSelector

	aSelectorの示すメッセージをレシーバに送信し、その結果を返します。

- \- (id) performSelector: (SEL) aSelector withObject: (id) anObject

	aSelectorの示すメッセージを、anObjectを引数としてレシーバに送信し、その結果を返します。

指定したセレクタに対応したメソッドがあるかを調べる
---------------------------------------------------

- \- (BOOL) respondsToSelector: (SEL) aSelector

	aSelectorの示すメッセージを処理できるメソッドが、レシーバに実装されているか、あるいはスーパークラスから継承されていればYESを返します。

- \+ (BOOL) instancesRespondToSelector: (SEL) aSelector

	レシーバとなるクラスが、aSelectorの示すメッセージを処理できるインスタンスメソッドを実装しているか、継承していればYESを返します。

メソッドに対応する関数へのポインタを取得する
--------------------------------------------

- \- (IMP) methodForSelector: (SEL) aSelector

	引数として指定したセレクタに対応するメソッドを調べて、その実装である関数へのポインタを返します。このメソッドはインスタンスオブジェクトにも、クラスオブジェクトにも使うことができます。
	インスタンスオブジェクトに対して使用した場合はインスタンスメソッドに対応する関数が返され、クラスオブジェクトに対応して使用した場合はクラスメソッドに対応する関数が返されます。

- \- (IMP) instanceMethodForSelector: (SEL) aSelector

	引数として指定したセレクタに対応するインスタンスメソッドを調べて、その実装である関数へのポインタを返します。

ターゲット-アクション・パラダイム
-------------------------------------

SEL型変数を用いることで、実行されるメソッドを動的に変更することが可能です。
Applicationフレームワークでは実際に、この仕組みを用いてGUI部品間のメッセージ送受信を実現しています。

.. code-block:: objective-c

	@interface myCell : NSObject {
		SEL action;
		id  target;
	}
	- (void)setAction:(SEL)aSelector;
	- (void)setTarget:(id)anObject;
	- (void)performClick:(id)sender;
	...
	@end

	@implementation myCell

	- (void)setAction:(SEL)aSelector {
		action = aSelector;
	}

	- (void)setTarget:(id)anObject {
		target = anObject;
	}

	- (void)performClick:(id)sender {
		(void)[target performSelector:action withOvject:sender];
	}
	...
	@end

このクラスでは、SEL型変数actionと、id型変数targetをインスタンス変数として持っています。このクラスのインスタンスに対してperformClick:メッセージが送られると、targetが保持しているオブジェクトに対してactionが表すメッセージが送られます。このとき、引数にはperformClick:の引数が使われます。

このようにして、ApplicationフレームワークではGUI部品オブジェクト間の通信を実現しています。これを **ターゲット-アクション・パラダイム** (target-action paradigm)、あるいは **ターゲット-アクション・メカニズム** と読んでいます。

アクションメソッド
^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: objective-c

	- (void) XXXXXX:(id)sender;
	
Applicationフレームワークの中でメッセージとして使用されるのは、このようなid型の引数を１つだけ持ち、戻り値のない形式のメソッドだけです（XXXXXXは任意のメッセージキーワード）。この形式のメソッドを **アクションメソッド** (action method)と呼びます。
あらかじめ設定されたtagetに、actionで指定されたメッセージが送られます。メッセージの引数には、通常、そのGUI部品のidが渡されます。これによって、targetで指定されたレシーバ側はのオブジェクトは、どの部品からどのようなメッセージが送られたのかを知ることができます。

.. Note::

	通常はターゲットとアクションの指定に、それぞれのメソッド「setTarget:」と「setAction:」が使われます。なお、カウンタ管理方式で利用している場合でも、setTarget:は引数のオブジェクトを保持（retain）しません。ARCを利用する場合には弱い参照を使うことが推奨されています。

iPhoneやiPadのGUI構築のためのフレームワークであるUIKitは、Applicationフレームワークと同じ概念を共通して持っているのですが、所々で異なる部分があります。
Applicationフレームワークのアクションメソッドの形式は１つでしたが、UIKitフレームワークでは、次の３つの形式がアクションメソッドとされています。

(1) \- (void)XXXXXX;

(2) \- (void)XXXXXX:(id)sender;

(3) \- (void)XXXXXX:(id)sender forEvent:(UIEvent*)event;





