=================
プロパティ
=================

機能的には、アクセサメソッドで実現していた概念を整理して簡潔に記述できるようにしたものと言えます。一方で、キー値コーティングではアクセサメソッドだけではなく、インスタンス変数が定義されているだけでも、それをプロパティとして扱うことができますので、キー値コーディングで言う、プロパティの方がより概念です。

Propertyの所有属性
==============================

プロパティの所有属性には以下の６種類があります。

================== ====================================================================
所有属性            説明
================== ====================================================================
strong             オーナーシップを持つ(参照カウントがincrementされる)
weak               オーナシップを持たない(参照カウントがincrementされない)。
                   オブジェクトが解放されるとnilを返す様になる。 
copy               コピーに対してオーナーシップを持つ(setterに渡されたオブジェクトの)
                   コピーを作るため、元のオブジェクトとは違うオブジェクトを持つ)
unsafe_unretained  retain(strongと同じ意味)せずに参照を持つ。weakが無い時代に使われた。
                   今となっては歴史的経緯で残ってるだけのやつで、使わない！
assign             intやBOOLのようなプリミティブな値を保持する際に使われる。単純な代入を
                   意味していて、オブジェクトに対して指定すると単なる参照の代入なので、
                   要はunsafe_unretainedなどと同じ。これもオブジェクトに対しては使わない！
retain             strongと同じ。完全に歴史的経緯で残っているだけなので、これも使わない！
================== ====================================================================

現在の開発では、このうち最初の３つの「strong」「weak」「copy」が利用されています。
ですが、これらの使い分けがいまいち分からなかったりします。ということで、細かく見て行きましょう。

オブジェクトを保持する場合とデフォルトはstrongを使おう
-------------------------------------------------------

所有属性を指定するときは、デフォルトではstrongを指定する事になります。(何も書かなかったら勝手にstrongが指定されています)

strongは参照カウントをincrementすると書きましたが、要は自明な保持者となる事を意味します。

Objective-Cにおいては、メモリ管理の方法として「参照カウンタ方式」と呼ばれるものを採用しており、自明な保持者が一人でもいればオブジェクトをメモリに残し、一人も居なくなればオブジェクトの解放を行います。
実装としてはオブジェクト毎に「参照カウント」という数を定義しておき、自明な保持者が増えるたびに「参照カウント」をincrement、自明な保持者が減れば「参照カウント」をdecrementする事で、参照カウントを見れば残っている保持者数が分かるようになっています。

では、strong属性以外のweakやcopyを使うのはどのような場面なのか、なぜstrong属性だけではダメなんでしょうか。その辺りを見て行きます。


weak属性の使いどころ
-----------------------
一般的には、「weak属性は循環参照を避けるために使用される」と説明されています。
では、循環参照とはそもそも何でしょうか。

循環参照
------------
複数のオブジェクトが互いにstrongで参照を持ち合っている状態ができてしまう事があります。いずれか１つが解放されれば、その他のオブジェクトも解放されるはずですが、１つでも参照が残っていると解放が行われないため、永遠にメモリ上に残り続けてしまいます。これを循環参照と言います。

この循環参照を避けるための解決策として、**weak属性** が使用されます。
weak属性を指定する事で、参照がカウンタがincrementされないので、オブジェクトの自明な保持者は片方のオブジェクト（親オブジェクト）だけになり、親オブジェクトが解放された時点で小オブジェクトは解放されます。

weak属性の使用例
-----------------------

weak属性が使われるシチュエーションとして、よく例に挙げられるのは次の３つです。

1. Outletプロパティ
2. デリゲートプロパティ
3. ブロックプロパティ

● Outletプロパティ
^^^^^^^^^^^^^^^^^^^^^

Outlet(IBoutlet)が参照するオブジェクトは、だいたいは何かのサブViewになっているはずです。ViewControllerからIBOutletで参照したりしますが、この時、参照するビューは親のViewがstrongで保持しているはずです。
ですので、ViewControllerからstrongで参照してしまうと、循環参照ができ、親のViewが解放されても、サブViewが解放されないということが起きてしまいます。そのため、Outletプロパティには **weak属性** で参照すべきです。

しかし、次にあげるものは例外としてstrongで参照するようにしてください。

- Nibのトップレベルオブジェクト（Windwow、他のViewに属さないView、NSObjectControllerなどのView以外のオブジェクト）
- サブViewのうち、**-removeFromSuperview**を呼ぶ等して、一時的にビュー階層から取り除かれる可能性のあるもの


● デリゲートプロパティ
^^^^^^^^^^^^^^^^^^^^^^^

あるオブジェクトの `Parent` が、別のオブジェクトChildを生成し、Childをstrongで保持しているとします。ChildがParentに何かの処理を委譲したければ、ChildはdelegateとしてParentを受け取る必要があります。

.. code-block:: objective-c

	// in Parent.h
	@property (nonatomic, strong) Child* child;

	// in Parent.m
	child.delegate = self;

ここまで、特に問題ありません。一般的な処理です。

ここで、Child.hでdelegateがstrong属性で宣言されているとどうなるか考えてみましょう。

.. code-block:: objective-c

	// Child.h
	@property (nonatomic, strong) id delegate;

この場合、ParentオブジェクトはプロパティとしてChildオブジェクトをstrongで持っており、ChildオブジェクトはdelgateプロパティとしてParentをstrongで持っているという **循環参照** が生まれてしまいます。

このような状況を避けるために、**delegateプロパティはweak指定すべき** と言われています。

.. code-block:: objective-c

	// Child.h
	@property (nonatomic, weak) id delegate;


● ブロックプロパティ内のself
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^




