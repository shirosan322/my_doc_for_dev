====================================
基礎的なプログラミング技術を習得する
====================================

その名前から分かるように、「Foundation」フレームワークは、iOSとOS Xの両方のすべてのプログラミングにとって、基本的なツールキットです。
これらのプラットフォームの開発者として成功するためには、このツールキットについて詳しくなっておく必要があります。

「Foundation」は、様々な目的のためのクラスやプロトコルを数十個定義していますが、特に基本的なものとして、クラスやプロトコルの３つのカテゴリがあります。

- *rootクラスと関係するプロトコル* 「NSObject」という同じ名前のプロトコルを持つrootクラスは、Objective-Cのすべてのオブジェクトの基本的なインターフェースと動作を指定しています。また、クラスのインスタンスをコピーしたり状態のコード化ができるように、クラスが採用できるプロトコルもあります。

- *Valueクラス* Value クラスは、（Valueオブジェクトと呼ばれる）インスタンスを生成し、これは、文字列、数値、日付、倍なりデータのようなプリミティブデータ型のためのオブジェクト指向のラッパーです。同じカプセル化された値をもつValueクラスのインスタンスは等しいと見なされます。

- *Collectionクラス* （コレクションと呼ばれる）Collectionクラスのインスタンスはオブジェクトのグループを管理します。コレクションの特定の型を区別することで、コレクションに含まれるオブジェクトにアクセスできます。多くの場合、Collection内の項目はValueオブジェクトです。

メソッドのパラメータや戻り値としてのオブジェクトを頻繁に探すため、「Collection」や「Value」オブジェクトは、Objective-Cプログラミングにおいて非常に重要です。

----------

RootクラスとObjetive-Cのオブジェクト
=======================================

クラス階層では、ルートクラスは何も継承しておらず、他のすべてのクラスは最終的にはこのクラスを継承しています。
「NSObject」がObjective-Cのクラス階層のルートクラスです。
他のクラスは、「NSObject」クラスからObjective-Cのランタイムシステムへの基本的なインターフェースを継承します。
また、これらのクラスのインスタンスは、Objective-Cのオブジェクトとしての基本的性質を「NSObject」クラスから導出しています。

しかし、「NSObject」インスタンスはシンプルなオブジェクトであることを越えて、それ自身が何か有用なことを行うことはできません。
プログラムに任意のプロパティやロジックの詳細を追加するためには、「NSObject」から継承するクラスか、「NSObject」直接または間接的にNSObjectを継承する他のクラスを１つ以上作成する必要があります。
「Your First Mac App」を通しての作業中に作成した「Track」クラスは、「NSObject」を直接継承しています。

「NSObject」は、NSObjectプロトコルを採用し、これは、すべてのオブジェクトのインターフェースに共通する追加メソッドを宣言しています。
加えて、「NSObject」は「NSCopying」「NSMutableCopying」「NSCoding」プロトコルを採用しています。
クラスがこれらのプロトコルを採用するとき、「object-copying」および「object-encoding」機能を備えた基本的なオブジェクトの動作を拡張します。
Modelクラス（インスタンスがアプリケーションデータをカプセルかしたり、管理するクラスである）は、頻繁に「object-copying」および「object-encoding」プロトコルを採用しています。

「NSObject」クラスとそれに関係するプロトコルは、オブジェクト生成するため、継承チェーンをナビゲートするため、特性や能力について問い合わせるため、オブジェクトを比較するため、オブジェクトをコピーしたりエンコードするためのメソッドを定義しています
この記事の残りの部分の多くは、これらのタスクのほとんどのための基本的な要件について説明しています。

------------

オブジェクトの観点から考える
===============================

実行時には、アプリケーションは恊働するオブジェクトのネットワークです。これらのオブジェクトは、アプリケーションが行った作業を取得するために、互いに通信を行います。
各オブジェクトは、酸くなうとも１つの責任を持った役割を果たしており、少なくとも１つの別のオブジェクトと接続されている。（孤立しているオブジェクトはほとんど価値がない）
下図に示すように、ネットワーク内のオブジェクトはフレームワークオブジェクトとアプリケーションオブジェクトを含んでいます。
アプリケーションオブジェクトはカスタムサブクラスのインスタンスで、通常、フレームワークのスーパークラスです。
オブジェクトネットワークは、一般に「object graph」として知られています。

	.. image:: images/app_as_object_network.png

参照を介して、オブジェクト間のこれらの接続や関係を確立します。
インスタンス変数、グローバル変数、（限られたスコープ内での）ローカル変数でさえも、参照のたくさんの言語形式があります。
関係は１対１または１対多になることが可能で、所有権または親子対応の考えを表現することができます。
これらは、オブジェクトが他のオブジェクトと接続、通信、制御をするための手段の1つです。
参照されるオブジェクトはメッセージの自然な受信機となります。

アプリ内のオブジェクト間のメッセージは、アプリケーションの機能的な統一性にとって非常に重要です。
オーケストラの音楽家と同じ方法で、アプリ内の各オブジェクトは役割やアプリケーションに貢献している動作の限られたセットを持っています。
オブジェクトは、タップに反応する楕円の面を表示したり、データベアリングオブジェクトのコレクションを管理したり、アプリケーションのライフに置ける主要なエベントを調整することが可能です。
その寄与が実現されるためではなく、他のオブジェクトを通信ができるようにならなければなりません。
アプリケーションないの他のオブジェクトにメッセージを送ることができることや他のオブジェクトからのメッセージを受信できることは必須です。

強結合されたオブジェクト（直接参照によって接続されたオブジェクト）によってメッセージを送ることは簡単です。
しかし、アプリケーションを疎結合しているオブジェクト（つまり、オブジェクトグラフ内で遠くは慣れているオブジェクト）は、他の通信手段を探す必要があります。
CocoaとCocoaタッチのフレームワークは、（下図で示すように）疎結合オブジェクト間の通信を可能にする、多くのメカニズムとテクニックを備えています。
これらのメカニズムやテクニックは、すべてデザインパターン（後で詳しく学びます）に基づいており、堅牢で拡張可能なアプリケーションを効率的に構築させることができます。

	.. image:: images/communication_loosely_coupled.png

----------

オブジェクトの生成
=====================

通常は、オブジェクトをアロケーションしてから初期化することでオブジェクトを生成します。
これらは２つの別々のステップですが、密接に関連しています。
また、多くのクラスはクラスファクトリメソッドを呼び出すことでオブジェクトを生成させることもあります。

アロケーションと初期化によるオブジェクトの生成
-----------------------------------------------

オブジェクトを割り当てるには、「alloc」メッセージをオブジェクトのクラスに送り、クラスの「生の」（初期化されていない）インスタンスを取得します。
オブジェクトを割り当てると、Objective-Cのランタイムはアプリケーションの仮想メモリからオブジェクトに十分なメモリを割り当てます。
メモリを割り当てることに加えて、ランタイムは、割り当て時にすべての変数に０をセットするといったようないくつかの別の処理を行います。

生のインスタンスを割り当てた直後に、それを初期化しなければなりません。
初期化は、オブジェクトの初期状態（インスタンス変数やプロパティ）を合理的な値に設定し、それからオブジェクトを返します。
初期化の目的は使用可能なオブジェクトを返すことです。

フレームワークには、オブジェクトを初期化するイニシャライザーと呼ばれる、たくさんのメソッドがあることが分かるでしょう。そして、それらはすべて同じような形態をしています。
イニシャライザーは「init」で始まり「id」型のオブジェクトを返すインスタンスメソッドです。
ルートクラスはである「NSObject」が「init」メソッドを宣言しており、他のすべてのクラスはこれを継承しています。
他のクラスは独自のイニシャライザを宣言しており、それぞれ独自のキーワードとパラメータを持っています。
たとえば、「NSURL」クラスは次のようなイニシャライザを宣言しています。

	.. code-block:: objective-c

		- (id)initFileURLWithPath:(NSString *)path isDirectory:(BOOL)isDir

オブジェクトを割り当てて初期化するとき、割り当ての呼び出しは、初期化の呼び出しの内側にネストします。
一例として、上記のイニシャライザを使用する場合、

	.. code-block:: objective-c

		NSURL *aURL = [[NSURL alloc] initFileURLWithPath:NSTemporaryDirectory() isDirectory:YES];

また、「TrackMix」アプリケーションを作成するとき、「Track」オブジェクトの割り当てと初期化を行いました。

	.. code-block:: objective-c

		Track *aTrack = [[Track alloc] init];

安全なプログラミングの練習として、オブジェクトが生成されたことを確認するために、返されたオブジェクトをテストすることができます。
もしも、どちらかの段階でオブジェクトの生成を妨げる何かが発生した場合、イニシャライザは「nil」を返します。
Objective-Cは、負の影響なしに（例えば例外のスローなしに）nilにメッセージを送ることができますが、あなたのコードはメソッドが呼び出されていないため期待どおりに動作しない場合があります。
「alloc」によって返されたものではなく、イニシャライザによって返されたインスタンスを使用するようにしましょう。

-------

クラスファクトリーメソッドを呼び出してオブジェクトを生成しよう
---------------------------------------------------------------

ファクトリーメソッドを呼び出すことでオブジェクトを作成することもできます。
ファクトリーメソッドは割り当てと初期化とインスタンスを返すことを目的としたクラスメソッドです。
クラスファクトリーメソッドは、２ステップではなく１ステップでオブジェクトの生成を作れるという点で便利です。
ファクトリーメソッドは以下のような形式で記述します。

	.. code-block:: objective-c

		+ (type)className... (where className excludes any prefix)

Objective-Cフレームワークのクラスは、クラスのイニシャライザに対応するク明日ファクトリーメソッドを定義していることがある。
たとえば、「NSString」は以下の２つのメソッドを宣言している。

	.. code-block:: objective-c

		- (id)initWithFormat:(NSString *)format, ...;
		+ (id)stringWithFormat:(NSString *)format, ...;

以下は、「NSString」のクラスファクトリーをどのようにして使うかの例です。

	.. code-block:: objective-c

		NSString *myString = [NSString stringWithFormat:@"Customer: %@", self.record.customerName];

-----------

メモリリークするのを防ぐためにオブジェクトグラフを管理する
============================================================

Objective-Cプログラムのオブジェクトは、オブジェクトブラフを構築している。これは、各オブジェクトと他のオブジェクトとの関係や参照によって形成されたオブジェクトのネットワークです。
オブジェクトの参照は、１対１か（コレクションオブジェクトのような）１対多のどちらかになっています。
オブジェクトグラフは、オブジェクトの寿命の要因であるため重要です。
コンパイラは、オブジェクトグラフ内の強参照を調べ、保持や解放のメッセージを適切な場所に追加します。

.. Note::

	Objective-Cランタイムの最近のバージョンでは、自動参照カウント(ARC)が実装されています。
	ARCは、（オブジェクトの確保や解放といった）メモリの管理を不要にしてくれます。
	あなたは、新しいアプリケーションプロジェクトでは、デフォルトであるARCを常に利用すべきです。

グローバル変数やインスタンス変数、そしてローカル変数のような、基本的なC言語やObjective-Cの構築物を通して、オブジェクト間の参照を形成しています。
これらの構築物のそれぞれが暗黙のスコープをもたらします。例えば、ローカル変数に参照されているオブジェクトのスコープは、それが宣言された機能ブロックです。
同様に重要なことは、オブジェクト間の参照は、強参照か弱参照のどちらかであることです。
強参照は所有権を示しており、参照しているオブジェクが参照されているオブジェクトを修しています。
弱参照は参照しているオブジェクトが参照されているオブジェクトの所有者ではないことを示しています。
オブジェクトの寿命は、そのオブジェクトに対する強参照がいくつ存在するかによって決定されます。オブジェクトは強参照があるかぎり解放されません。

Objective-Cの参照は、デフォルトでは強参照です。
これはたいていの場合は良いことで、コンパイラはオブジェクトを使用している間、解放しないようにオブジェクトのランタイムの寿命を管理することが可能になります。
しかしながら、気をつけなければ、オブジェクト間の強参照は下図の左側に示すように、切れ目のない参照の連鎖を形成することができてします。
そのような切れ目の無い連鎖では、それぞれのオブジェクトに強参照があるために、ランタイムががオブジェクトを解放しないことがあり得ます。
その結果、強参照サイクルがあなたのプログラムのメモリリークの原因となってしまう可能性があります。

	.. image:: images/strong-ref-cycle-weak-ref.png

この図におけるオブジェクトの場合、もしもAとBの間の参照が壊れれば、B,C,D,Eから成る部分グラフは、これらのオブジェクトが強参照のサイクルで結びつけられているため、「永遠」に生き続けます。
EからBに弱参照を導入することで、この強参照のサイクルを壊すことができます。

このようにして、賢明な弱参照の使用で、強参照サイクルを修正することができます。
ランタイムは、オブジェクトへの強参照だけでなく、弱参照のトラックも保持しします。
オブジェクトの強参照が存在しないとき、オブジェクトを解放し、すべての弱参照のオブジェクトに「nil」を設定します。
変数（グローバル、インスタンス、ローカル）では、弱参照であることを示すために、変数名の直前に「__weak」修飾子を使用します。プロパティには、「weak」オプションを使用します。
以下のような種類の参照には、弱参照を使用すべきです。

	- 「Delegates」

		.. code-block:: objective-c

			@property (weak) id delegate;

		デザインパターンに関する記事である「Streamline Your App with Design Patterns」でdlegatesとtargetのついて学習します。

	- トップレベルのオブジェクトへの参照でない「Outlet」

		.. code-block:: objective-c

			@property (weak) IBOutlet NSString *theName;


		OutletはStoryBoardやnibファイルにアーカイブされたオブジェクトや、アプリケーションがStoryBoardやnibファイルをロードしたときに格納されるオブジェクトの間の接続（または参照）です。
		StoryBoardやnibファイル内の最上位のOutlet（通常は、Window, View, View Controller）は、強参照であるべきです（デフォルトなので気づかない）。

		AppKitフレームワークの特定クラスのためのOutletプロパティ（たとえば「NSWindow」）は、このルールの例外です。これらは割り当てのオプションを指定して宣言する必要があります。

	- 「Targets」

		.. code-block:: objective-c

			(void)setTarget:(id __weak)target

	- ブロック内の「slef」への参照

		.. code-block:: objective-c

			__block typeof(self) tmpSelf = self;
			[self methodThatTakesABlock:^ {
				[tmpSelf doSomething];
			}];

		ブロックはキャプチャした変数への強参照を形成します。
		もしも、ブロック内で「self」を使用すれば、ブロックは「self」への強参照を形成します。そして、もしも「self」もブロックへの強参照を持っていれば（通常はありません）、強参照サイクルをもたらします。

		このサイクルを避けるために、上記の例のように、ブロックの外に「slef」への弱参照（または__block）を作成する必要があります。

----------

オブジェクトの変わりやすさ（Mutability）の管理
================================================

変更可能なオブジェクトはオブジェクトを生成した後にその状態を変更することができます。
通常は、プロパティまたはアクセッサメソッドを通して、変更を行います。
普遍オブジェクトは、オブジェクトを生成した後に、そのカプセル化された状態を変更することはできません。
Objective-Cフレームワークのほとんどのクラスのインスタンスは変更可能ですが、いくつかは不変です。
不変オブジェクトは、以下のような利点を提供します。

	- 不変オブジェクトは、使用中に意図せず値を変更してしまうことがありません。

	- 多くの種類のオブジェクトにとって、オブジェクトが不変であれば、アプリケーションのパフォーマンスが向上します。

Objective-Cフレームワークでは、不変クラスのインスタンスは、通常、配列や文字列のように、離散またはバッファリングされたコレクションをカプセル化したものです。
これらのクラスは、通常、名前に「Mutable」のついた、変更可能な形を持っている。
たとえば、「NSString」（不変）やと「NSMutableString」クラスがあります。
「NSNumber」や「NSDate」のような離散的な値をカプセル化した不変なオブジェクトは変更可能な形を持っていないことに注意してください。
オブジェクトの内容を段階的、または頻繁に変更することが予想されるん場合は、不変オブジェクトに変わって可変オブジェクトを使用してください。
もしも、不変オブジェクトとして型指定されたフレームワークからのオブジェクトを受け取った場合は、受け取った型を遵守し、オブジェクトを変更しないでください。

--------------

Valueオブジェクトの作成と使用
================================

Valueオブジェクトはプリミティブ値（C言語のデータ型）をカプセル化し、その値に関連するサービスを提供するオブジェクトです、
Valueオブジェクトは、オブジェクト形式でスカラー型を表しています。
Foundationフレームワークは、文字列、バイナリデータ、日付と時刻、数値、その他のオブジェクト、のために以下のようなオブジェクトが提供されています

	- 「MSString」「NSMutableString」
	- 「NSData」「NSMutableData」
	- 「NSDate」
	- 「NSNumber」
	- 「NSValue」

Valueオブジェクトは、Objective-Cプログラミングにおいて重要です。
パラメータやアプリケーションで呼び出すメソッドや関数の戻り値として、これらのオブジェクトは頻繁に目にするでしょう。
Valueオブジェクトを渡すことで、フレームワークの別の部分や、別のフレームワークでさえデータを変更することができます。
Valueオブジェクトがスカラー値を表すため、これらのオブジェクトをコレクションで使うことができますし、別のオブジェクトが必要とされるところでどこでも使用することができます。
しかし、これらの共通性と結果しての必要性以上に、Valueオブジェクトはカプセル化しているプリミティブ型よりも有利である、
というのも、これらはシンプルで効率的な方法で、カプセル化された値の特定の操作を実行することができます。
たとえば、「NSString」クラスは、部分文字列を探したり置換したりするメソッド、文字列をファイルやURLに書き込むメソッド、ファイルシステムパスを構築するメソッド等を持っています。

Valueオブジェクトによって、より効率的にかつ簡単にプリミティブ型（int(integer), float 等）を使えることに気づくことがあります。
主な例では値の計算を行います。
結果として、「NSNumber」や「NSValue」オブジェクトがフレームワークメソッドのパラメータや戻り値として一般的でありません。
フレームワークの多くは独自の数値データ型を持っており、これらのかたをパラメータや戻り値として使用していることを覚えておいてください。たとえば、「NSInteger」「CGFloat」。
下層のプラットフォームからあなたのコードを取り除く助けになるので、適切な場所でこれらのフレームワークで定義された型を使用するようにしましょう。

Valueオブジェクトの基本的な使い方
-----------------------------------

Valueオブジェクトを作成するための基本的なパターンは、あなたが書いたコードまたはプリミティブ型のデータから作成する（そして、おそらくそれをメソッドのパラメータとして渡す）ためのフレームワークのコードです。
あなたのコードでは、後で、オブジェクトからカプセル化されたデータにアクセスします。
「NSNumber」クラスは、これの明確な例を提供してくれます。

	.. code-block:: objective-c

		int n = 5; // Value assigned to primitive type
		NSNumber *numberObject = [NSNumber numberWithInt:n]; // Value object created from primitive type
		int y = [numberObject intValue]; // Encapsulated value obtained from value object (y == n)

ほとんどの「Value」クラスは、イニシャライザとクラスファクトリメソッドが両方とも宣言されています。
いくつかのクラス（特に「NSString」や「NSData」）は、イニシャライザと、ローカルまたはリモートのファイルに格納されているプリミティブデータからだけでなく、メモリ上のデータからもインスタンスを生成するクラスファクトリメソッドを提供しています。
これらのクラスは、文字列やバイナリデータをファイルやURLで指定した場所に書き込むための補完的なメソッドも提供しています。
以下のサンプルコードでは、URLオブジェクトによって配置されたファイルの内容から「NSData」オブジェクトを作成するために「initWithContentsOfURL:」メソッドを呼び出しています。このデータを使用した後、コードはシステムにデータオブジェクトを書き込みます。

	.. code-block:: objective-c

		NSURL *theURL = // Code that creates a file URL from a string path...
		NSData *theData = [[NSData alloc] initWithContentsOfURL:theURL];
		// use theData...
		[theData writeToURL:theURL atomically:YES];

Valueオブジェクトを作成しカプセル化した値にアクセスできることに加えて、ほとんどのValueクラスはオブジェクトの比較のような単純な操作をするメソッドを提供しています。

Valueクラスのインスタンスをプロパティとして宣言するときは、「copy」オプションを使いましょう。

文字列とNSStringリテラル
--------------------------

C言語のスーパーセットとして、Objective-CはC言語と同じように文字列を指定するのに、同じ規則をサポートしています。
言い換えると、単一文字はシングルクォーテーション、文字列はだぶるクォーテーションで囲みます。
しかしながら、Objective-Cフレームワークは通常Cの文字列を使用しません。
代わりに、「NSString」を使用します。

「NSString」クラスは文字列のオブジェクトラッパーを提供し、それによって、任意の長さの文字列を格納するためのビルドインメモリ管理のような利点を提供することで、異なる文字エンコーディング（特にユニコード）やprintfスタイルのフォーマットユーティリティにも対応している。
このような文字列を一般的に使用するため、Objective-Cは、定数から「NSString」オブジェクトを作成するための簡略表記を提供しています。
この「NSString」リテラルを使用するためには、以下の例のように、ダブルクォーテーションで囲まれた文字列のすぐ前にアットマーク（＠）を置きます。

	.. code-block:: objective-c

		// Create the string "My String" plus carriage return.
		NSString *myString = @"My String\n";
		// Create the formatted string "1 String".
		NSString *anotherString = [NSString stringWithFormat:@"%d %@", 1, @"String"];
		// Create an Objective-C string from a C string.
		NSString *fromCString = [NSString stringWithCString:"A C string" encoding:NSASCIIStringEncoding];

NSNumberリテラル
------------------

Objective-Cは、「NSNumber」オブジェクトを作成するためにも簡略表記を提供しており、このようなオブジェクトを生成するのにイニシャライザやファクトリメソッドを必要としません。
単純に、数値の前にアットマーク（＠）を置き、必要に応じてその後にValueタイプ表示を行ってください。
たとえば、integer値やdouble値をカプセル化している「NSNumber」オブジェクトを作成するために、それぞれ、次のように書くことができます。

	.. code-block:: objective-c

		NSNumber *myIntValue    = @32;
		NSNumber *myDoubleValue = @3.22346432;

カプセル化されたBooleanや文字コードを作成するために「NSNumber」リテラルを使うこともできます。

	.. code-block:: objective-c

		NSNumber *myBoolValue = @YES;
		NSNumber *myCharValue = @'V';

符号なしinteger、long integer、long long integer、float等の値も、「U」「L」「LL」「F」の文字をそれぞれ後ろに付けることで、
表現することができます。

	.. code-block:: objective-c

		NSNumber *myFloatValue = @3.2F

日付（Date）と時間(Time)
----------------------------

NSDateオブジェクトは、プリミティブ値としての時間の独特な働きのために、他の種類のValueオブジェクトとは異なっています。
Dateオブジェクトは、基準日からの間隔を秒単位でカプセル化しています。
基準日は2001年01月01日GMTが最初の瞬間です。

NSDateのインスタンスだけでは少しのことしか行えません。
NSDateは時間のある瞬間を表していますが、その表現はカレンダーやタイムゾーンや地域の時間的な規則によって提供されているコンテキストがありません。
幸い、これらの概念的な実態を表すFoundationクラスがあります。

	- 「NSCalendar」と「NSDateComponents」:日付をカレンダーと関連付けてから、年、月、時間、曜日といった日付をカレンダーから時間の単位で取得することができます。また、暦計算を実行することも可能です。

	- 「NSTimeZone」：日時は、地域のタイムゾーンを反映する必要があるとき、タイムゾーンオブジェクトとカレンダーを関連づけることができます。

	- 「NSLocale」：ロケールオブジェクトは、時間に関するものを含む、文化的、言語的規則をカプセル化しています。

次のコードスニペットは、欲しい情報（この場合、時間、分、秒、で表す現在の時間）を取得するために、どのようにしたらこれらの他のオブジェクトと一緒に「NSDate」オブジェクトを使用できるかを示しています。
説明用の以下のコードは

	.. code-block:: objective-c

		NSDate *now = [NSDate date]; // 1
		NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar]; // 2
		[calendar setTimeZone:[NSTimeZone systemTimeZone]]; // 3
		NSDateComponents *dc = [calendar components:(NSHourCalendarUnit|NSMinuteCalendarUnit|
					NSSecondCalendarUnit) fromDate:now];  // 4
		NSLog(@"The time is %d:%d:%d", [dc hour], [dc minute], [dc second]); // 5

	1. 現在の瞬間を表すDateオブジェクトの生成します。
	2. グレゴリオ暦を表すオブジェクトの生成します。
	3. システム環境設定で指定されたタイムゾーンを表すオブジェクトでカレンダーオブジェクトを設定します。
	4. 手順1.で作成したDateオブジェクトを渡して、カレンダーオブジェクトの「components:fromDate:」メソッドを呼び出してください。この呼び出しは、Dateオブジェクトの内容として、時間、分、秒含んだオブジェクトを返します。
	5. 現在の時間、分、秒、をコンソールにログ出力しています。


この例では結果をログに出力していますが、アプリケーションのユーザーインターフェースで日付の情報を表示するための好ましいアプローチは、日付フォーマッタ（NSDateFormatterクラスのインスタンス）を使用することです。


コレクションの作成と使用
=============================

コレクションは、特定の方法で他のオブジェクトを格納し、クライアントがオブジェクトにアクセスできるようにするオブジェクトです。
多くの場合、メソッドや関数のパラメータとしてコレクションを渡し、メソッドや関数の戻り値としてコレクションを取得します。
コレクションはたいていValueオブジェクトを含んでいますが、コレクションはどんな型のオブジェクトでも含めることが可能です。
ほとんどのコレクションは、含まれているオブジェクトへの強参照を持っています。

Foundationフレームワークには、数種類のコレクションがありますが、そのうちの３つはCocoaとCocoa Touchプログラミングで特に重要です。(Array, Dictionary, Set)
これらのコレクションのクラスは、不変と可変の形をとっており、可変コレクションはオブジェクトの追加や削除を可能にしますが、不変コレクションは作成したときのオブジェクトしか含まれていません。
すべてのコレクションは、内容物を列挙することができるようになります。言い換えれば、含まれているオブジェクトのそれぞれを順番に調べることができるようになります。

異なるコレクションの種類は、独特の方法で含んでいるオブジェクトを編成しています。

	- 「NSArray」「NSMutableArray」：配列はオブジェクトの順序付きコレクションです。配列における位置（インデックス）を指定することで、オブジェクトにアクセスします。配列の最初の要素はインデックス０です。

	- 「NSDictionary」「NSMutableArray」：「Dictionary」はKeyとValueのペアとした入力を格納します。KeyはユニークなIDで、通常文字列を使用します。Valueは格納したいオブジェクトです。Keyを指定することで、オブジェクトにアクセスします。

	- 「NSSet」「NSMutableSet」：Setは順序なしオブジェクトのコレクションで、それぞれのオブジェクトは１度だけ現れます。Set内のオブジェクトにテストやフィルターを適用することで、Set内のオブジェクトにアクセスします。

	.. image:: images/collections.png

	コレクションの格納、アクセス、パフォーマンス特性のために、コレクションの種類は特定のタスクについて、他のものよりもより適していることがありえます。

	ArrayやDictionaryを作成し、「NSArray」や「NSDictionary」のメソッドを呼び出すか、Objective-Cの特別のコンテナリテラルや添字指定技術によって、それらの中の値にアクセスすることが可能です。
	以下のセクションでは、両方のアプローチについて説明しています。


Arrayに特定の順序でオブジェクトを格納しよう
---------------------------------------------

Arrayは順番にオブジェクトを格納します。従って、コレクション内のオブジェクトのジョン序が重要であるときに、Arrayを使用します。
たとえば、多くのアプリケーションはTableViewの行やメニューの項目にコンテンツを与えるためにArrayを使用します。
インデックス０のオブジェクトは最初の行に対応しており、インデックス１は２番目の行に対応しているといった感じです。
Array内のオブジェクトへのアクセス時間はSet内のオブジェクトのアクセスよりは遅くなります。

Arrayの作成
^^^^^^^^^^^^^^^

「NSArray」クラスは、Arrayに生成と初期化のために、たくさんのイニシャライザとクラスファクトリメソッドをを提供していますが、この中でも2,3個が特に一般的で有用です。
「arrayWithObjects:count:」や「arrayWithObjects:」メソッド（およびこれらに対応するイニシャライザ）で、一連のオブジェクトからArrayを作成することができます。
前者の方法では、２番目のパラメータは１番目のパラメータ内のオブジェクトの数を指定します。
後者の方法では、nilを含むカンマ区切りの一連のオブジェクトで終了します。

	.. code-block:: objective-c

		// Compose a static array of string objects
		NSString *objs[3] = {@"One", @"Two", @"Three"};
		// Create an array object with the static array
		NSArray *arrayOne = [NSArray arrayWithObjects:&(*objs) count:3];
		// Create an array with a nil-terminated list of objects
		NSArray *arrayTwo = [[NSArray alloc] initWithObjects:@"One", @"Two", @"Three", nil];

可変配列を作成するとき、「arrayWithCapacity:」（もしくは「initWithCapacity:」）メソッドを使用することができます。
capacityパラメータはArrayの予想されるサイズについてクラスにヒントを与えます。つまり、ランタイムにとって、より効率的にArrayを作成できます。
また、Arrayは指定された容量を超えることがあります。

「@[...]」という形式のコンテナリテラルを使用してArrayを作成することもできます。括弧内の項目はカンマで区切られたオブジェクトです。
たとえば、文字列、数値、日付を含むArrayを作るためには、以下のように記述します。

	.. code-block:: objective-c

		NSArray *myArray = @[ @"Hello World", @67, [NSDate date] ];


Array内のオブジェクトにアクセスする
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

一般的に、Array内のオブジェクトにアクセスするためには、（０基準の）インデックス位置を指定して「objectAtIndex:」を呼び出します。

	.. code-block:: objective-c

		NSString *theString = [arrayTwo objectAtIndex:1]; // returns second object in array

「NSArray」はArray内のオブジェクトやインデックスにアクセスする他のメソッドも提供しています。
たとえば、「lastObject」「firstObjectCommonWithArray:」「indexOfObjectPassingTest:」があります。
Array内のオブジェクトにアクセスするために「NSArray」のメソッドを使用する代わりに、添字指定記法を使用することも可能です。
たとえば、「myArray」（上記で作成したもの）の２番目のオブジェクトにアクセスするためには、次のように書くことができます。

	.. code-block:: objective-c

		id theObject = myArray[1];

Arrayで行う別の一般的なタスクは、Array内の各オブジェクトで何かを行うことです。これは、列挙として知られる方法です。
あなたは、多くの場合、１つ以上のオブジェクトが特定の値や状態に一致しているかどうかを判断し、もしも一致していればアクションを完了します。
列挙型のArrayには、「高速列挙」「ブロックとの列挙」「NSEnumeratorオブジェクト」の３つのアプローチから採用することができます。
「高速列挙（Fast Enumration）」は、名前が示すように、Array内のオブジェクトにアクセスする他の技術を使用するよりも、典型的により速くアクセスできます。
「高速列挙」は特定の構文が必要になる言語機能です。

	.. code-block:: objective-c

		for (型 変数 in Array){ /* inspect variable, do something with it */ }

例）

	.. code-block:: objective-c

		NSArray *myArray = // get array
		for (NSString *cityName in myArray) {
		    if ([cityName isEqualToString:@"Cupertino"]) {
		        NSLog(@"We're near the mothership!");
		        break;
		    }
		}

可変配列(MutableArray)を管理する
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

「NSArray」は、配列をソートしたり、検索したり、Array内のオブジェクトのメソッドを呼び出す他の関数も持っています。
「addObject:」メソッドを呼び出すことで、可変配列にオブジェクトを追加することができます。
可変長配列の特定の位置にオブジェクトを置くために「insertObject:atIndex:」を使用することもできます。
「removeObject:」メソッドか「removeObjectAtIndex:」オブジェクトを呼び出すことで、可変長配列からオブジェクトを削除することもできます。
添字指定記法で可変長配列の特定の位置にオブジェクトを挿入することも可能です。

	.. code-block:: objective-c

		NSMutableArray *myMutableArray = [NSMutableArray arrayWithCapacity:1];
		NSDate *today = [NSDate date];
		myMutableArray[0] = today;

Key-Valueの組み合わせをDictionaryに格納しよう
------------------------------------------------

オブジェクトをKeyとValueの組み合わせで格納するのにDictionaryを使用することができます。つまり、ID（Key）がオブジェクト（Value）を結びつけています。
Key-Valueの組は任意の順番で指定できるので、Dictionaryは順不同コレクションです。
Keyは事実上どんなものでも構いませんが、Valueを表す文字列にするのが典型的です。たとえば、「NSFileModificationDate」か「UIApplicationStatusBarFrameUserInfoKey」（これは文字列定数です）など。
公開鍵が存在する場合は、Dictionaryはあらゆる種類のオブジェクト間の情報を渡すのに優れた方法です。

Dictionaryの作成
^^^^^^^^^^^^^^^^^^^^^

イニシャライザやクラスファクトリメソッドを通して、「NSDictionary」クラスはDictyionaryを作成するための多くの方法がありますが、「dictionaryWithObjects:forKeys:」と「dictionaryWithObjectAndKeys:」（もしくはこれらに対応するイニシャライザ）の２つのクラスメソッドが特に一般的です。
前者のメソッドでは、オブジェクトの配列とKeyの配列を渡します。位置的にKeyとValueが対応している必要があります。
２番目のメソッドでは、最初のオブジェクトとそのそのKeyを指定し、次に２番目のオブジェクトとKeyを指定し、....となります。一連のオブジェクトの組の終了は「nil」で知らせます。

	.. code-block:: objective-c

		// First create an array of keys and a complementary array of values
		NSArray *keyArray = [NSArray arrayWithObjects:@"IssueDate", @"IssueName", @"IssueIcon", nil];
		NSArray *valueArray = [NSArray arrayWithObjects:[NSDate date], @"Numerology Today", self.currentIssueIcon, nil];

		// Create a dictionary, passing in the key array and value array
		NSDictionary *dictionaryOne = [NSDictionary dictionaryWithObjects:valueArray forKeys:keyArray];

		// Create a dictionary by alternating value and key and terminating with nil
		NSDictionary *dictionaryTwo = [[NSDictionary alloc] initWithObjectsAndKeys:[NSDate date],
	    @"IssueDate", @"Numerology Today", @"IssueName", self.currentIssueIcon, @"IssueIcon", nil];

Arrayと同様に、「@{ket : value, ...}」といった形のコンテナリテラルを使用することで、「NSDictionary」オブジェクトを作成することができます。ここで「...」はいくつかのKeyとValueの組み合わせのことを示しています。
たとえば、次のコードは３つのKeyとValueの組み合わせで、不変Dictionaryのオブジェクトを生成しています。

	.. code-block:: objective-c

		NSDictionary *myDictionary = @{
			@"name" : NSUserName(),
			@"date" : [NSDate date],
			@"processInfo" : [NSProcessInfo processInfo]
		};


Dictionary内のオブジェクトにアクセスする
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

パラメータとしてKeyを指定して「objectKey:」メソッドを呼び出すことで、Dictionary内のオブジェクトにアクセスします。

	.. code-block:: objective-c

		NSDate *date = [dictionaryTwo objectForKey:@"IssueDate"];

添字指定を使用してDictionary内のオブジェクトにアクセスすることも可能です。Keyは右側のDictionary変数の括弧内に置きます。

	.. code-block:: objective-c

		NSString *theName = myDictionary[@"name"];

可変長Dictionaryを管理する
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

「setObject:forKey:」や「removeObjectForKey:」メソッドを呼び出すことで、可変長Dictionaryに項目を挿入したり削除したりできます。
「setObject:forKey:」は、指定されたKeyの既存のValueを置き換えます。これらのメソッドを高速です。

可変長Dictionaryに、KeyとValueの組み合わせを追加するために、添字指定を利用することもできます。
Keyは割り当ての左側の添字指定で、Valueが右側にあります。

	.. code-block:: objective-c

		NSMutableDictionary *mutableDict = [[NSMutableDictionary alloc] init];
		mutableDict[@"name"] = @"John Doe";

Setに順不同のオブジェクトを格納する
--------------------------------------

「Set」は、含まれている項目が順序付きでなく順不同であることを除いて「Array」とよく似たオブジェクトコレクションです。
インデックス指定かKeyを使用してSetなのオブジェクトにアクセスするよりも、コレクションの列挙やSetにフィルターやテストを適用することで（あらゆるオブジェクトに）ランダムにアクセスします。

SetオブジェクトはDictionaryやArrayと同じようにObjective-Cプログラミングで一般的であるわけではありませんが、これらは特定の技術の重要なコレクションタイプです。

CoreData（データ管理技術）では、対多関係のプロパティを宣言するとき、プロパティは「NSSet」か「NSOrderedSet」にすべきです。

順序付きSetは、Setの基本的な定義の例外があります。順序付きSetはでは、Set内に項目の順序が重要です。
順序付きSet内のメンバーをテストすることは、Arrayのそれに比べて高速です。


ランタイムにおけるオブジェクトの能力の検証
==========================================

Objective-CとNSObjectクラスの強力かつ便利な機能を詳しく見ることで、ランタイムにおけるオブジェクトについて確かのことが学べるようになります。
これによって、見分けがつかないオブジェクトにメッセージを送ったり、オブジェクトが継承していないはずのクラス継承していると推測してしまうようなミスを避けることができます。

オブジェクトが実行時に自身について漏らすことができる情報に、重要な３つの種類があります。

	- 特定のクラスやサブクラスのインスタンスかどうか

	- そのメッセージに応答するかどうか

	- プロトコルに準拠しているかどうか

オブジェクトが特定のクラスかサブクラスのインスタンスかどうかを発見する
-----------------------------------------------------------------------

オブジェクトがあるクラスかそのサブクラスのインスタンスかどうかを検出するためには、オブジェクトの「isKindOfClass:」メソッドを呼び出します。
アプリケーションが応答する（実装または継承された）メッセージを発見したいとき、アプリケーションにこのチェックをさせます。

	.. code-block:: objective-c

		static int sum = 0;
		for (id item in myArray) {
			if ([item isKindOfClass:[NSNumber class]]) {
				int i = (int)[item intValue];
				sum += i;
			}
		}

「isKindOfClass:」メソッドはパラメータとして「Class」型のオブジェクトをとります。
このオブジェクトを取得するには、クラスシンボル上の「class」メソッドを呼び出します。
このメソッドに返されたBoolean値を評価し、それに応じて続行します。

「NSObject」はオブジェクトの継承に関する情報を発見するための他のメソッドも宣言しています。
たとえば、「isMemberOfClass:」メソッドはオブジェクトがある特定クラスのインスタンスであるかどうかを教えてくれます。一方で、「isKindOfClass:」メソッドはオブジェクトがそのクラスかその子孫クラスのメンバーであるかどうかを教えてくれます。


オブジェクトがメッセージに応答するかどうかを発見する
-----------------------------------------------------

これを行うためには、オブジェクトの「respondsToSelector:」メソッドを呼び出します。
アプリケーションのコードは、たいてい、オブジェクトにメッセージを送る前に、オブジェクトがメッセージに応答するかを検証します。

	.. code-block:: objective-c

		if ([item respondsToSelector:@selector(setState:)]) {
			[item setState:[self.arcView.font isBold] ? NSOnState : NSOffState];
		}

「respondsSelector:」メソッドは、パラメータとしてselectorをとります。Selectorは、メソッドを識別するランタイム用のObujective-Cのデータ型の1つです。
「@selector」コンパイラディレクティブを使用して指定します。
あなたのコードで、このメソッドが返すBoolean値を評価して、それに応じて続行します。

オブジェクトが応答するメッセージを識別するために、「respondsToSelector:」の呼び出しは、クラス型の評価よりも便利であり、一般的です。
たとえば、最新のバージョンのクラスは以前のバージョンにはないメソッドを実装する場合があります。

プロトコルに準拠しているかどうかを発見する
--------------------------------------------

これを行うためには、オブジェクトの「conformsToProtocol:」メソッドを呼び出します。

	.. code-block:: objective-c

		- (void) setDelegate:(id __weak) obj {
			NSParameterAssert([obj conformsToProtocol:@protocol(SubviewTableViewControllerDataSourceProtocol)]);
			delegate = obj;
		}

「conformsToProtocol:」メソッドはパラメータとしてプロトコル識別子をとります。
この識別子は「@protocol:」コンパイラディレクティブを使用して指定します。
このメソッドが返すBoolean値を評価して、それに応じて続行します。
オプションメソッドを実装することなく、プロトコルに準拠できるオブジェクトでは注してください。


オブジェクトの比較
======================

「isEqual:」メソッドをを使用することで、２つのオブジェクトを比較することができます。
メッセージを受け取ったオブジェクトが渡されたオブジェクトと比較され、同じであれば、メソッドは「YES」を返します。例えば、次のように、

	.. code-block:: objective-c

		BOOL objectsAreEqual = [obj1 isEqual:obj2];
		if (objectsAreEqual) {
			// do something...
		}

オブジェクトの等価性はオブジェクトのIDとは異なっていることに注意してください。
２つの変数が同じインスタンスであるかどうかを指す場合は、等価演算子（==）を使用してください。

同じクラスの２つのオブジェクトを比較するとき、何を比較しますか？これはクラスによって異なるのです。
ルートクラスである「NSObject」は比較の基準として、ポインタの等価性を使用します。
どのレベルのサブクラスも、オブジェクトの状態のような、クラス固有の基準における比較を基に、スーパークラスの実装をオーバーライドできます。
たとえば、仮の「Person」オブジェクトで、名字、名前、誕生日の属性が２つのオブジェクトで一致する場合、それらが等しいことが考えられます。

FoundationフレームワークのValueとCollectionクラスは、「isEqualTo *Type* :」という比較メソッドを宣言しています。「Type」は「NS」接頭辞を抜いたクラス型で、「isEqualToString：」や「isEqualToDictionary：」があります。
比較メソッドは、渡されたオブジェクトが指定されたタイプのものであることを想定しており、そうでない場合は例外を発生させます。

オブジェクトのコピー
=======================

「copy」メッセージを送ることでオブジェクトをコピーすることができます。

	.. code-block:: objective-c

		NSArray *myArray = [yourArray copy];

コピーされるためには、受信側オブジェクトのクラスが「NSCopying」プロトコルに準拠している必要があります。
もしも、オブジェクトをコピー可能にしたい場合は、このプロとコロルの「copy」メソッドを採用し、実装する必要があります。

オブジェクトを使用している間、オブジェクトの状態が変わらないことを保証したいとき、プログラム内の別の場所から取得したオブジェクトをコピーするときがあります。

コピー動作は、クラス固有のもので、インスタンスの特定の性質に依存します。
ほとんどのクラスは、ディープコピーを実装しており、すべてのインスタンス変数とプロパティを複製します。（collectionクラスのような）いくつかのクラスは、シャローコピーを実装しており、これは、インスタンス変数とプロパティの参照のみ複製します。

可変、不変の変数を持っているクラスも、オブジェクトの変更可能なコピーを作成するための「mutableCopy」メソッドを宣言しています。
たとえば、「NSString」オブジェクトの「mutableCopy:」を呼び出すと、「NSMutableString」のインスタンスを取得できます。
